# Архитектура и реализация CLI

## Что это?

Это интерпретатор командной строки (CLI), разработанный в следующей команде:
* Кузиванов Сергей
* Самсонов Павел
* Суркис Антон

## Куда смотреть?

* `app/*` — папка с реальной программой (точка входа + окружение, в котором всё работает)
* `src/*` — папка с абстрактной программой, то есть все действия происходят в пока неизвестном окружении (сделано для упрощения тестирования)
  * `src/Phases/*` — модули с фазами (этапами) обработки пользовательского запроса
  * `src/Data/*` — модули с типами данных, используемых в программе
  * `src/Monads/*` — модули с классами типов, расширяющих класс `Monad` путём добавления новых полезных функций (все функции вместе создают необходимый в работе программы интерфейс `IO`-like монады)
* `test/*` — папка с unit-тестами на фазы (на все кроме первой)

## Как собрать?

Нужна система сборки `stack` для Haskell. Рекомендуемый способ установки — через [GHCup](https://www.haskell.org/ghcup/).
Это же требование распространяется и на тестирование и запуск из рабочего окружения.

Для сборки из корневой директории проекта ввести:
```sh
stack build
```

## Как запустить?

```sh
stack run
```

Перед запуском произойдёт сборка (если необходимо) + могут быть записаны различные предупреждения, касающиеся `stack`а.
Для простого запуска собранного приложения под Linux можно написать

```sh
`stack path --local-install-root 2> /dev/null`/bin/cli-exe
```

## Как протестировать?

Для запуска модульных тестов наберите

```sh
stack test
```

Для вывода на консоль промежуточных представлений каждого пользовательского запроса необходимо использовать переменную `DEBUG_OPTIONS`,
а именно для того, чтобы получить промежуточное представление запроса после этапа `X` нужно добавить в переменную `DEBUG_OPTIONS` символ `Y`. Список вида `Y — X`:

* `r` — `reader` (считывает пользовательский ввод)
* `s` — `substitutor` (подставляет значения переменных в пользовательский запрос)
* `p` — `parser` (разбирает запрос и проводит первичный анализ)
* `a` — `analyzer` (анализ запроса, проверка правильности аргументов и т. д.)
* `l` — `linker` (построение плана выполнения запроса и его оптимизация)

Таким образом, чтобы получать полную информацию по каждому из запросов, достаточно набрать

```sh
DEBUG_OPTIONS=rspal
```

## Какая архитектура?

В этом разделе представлены материалы по архитектуре данной программы.

[Ссылка](https://drive.google.com/file/d/1Nv47i6H_2Y60PWEcxgYel1UN4rp1yos5/view?usp=sharing) на диаграммы.

### Окружение

![](./images/monads.svg)

В данном случае под окружением мы понимаем монаду, которая предоставляет доступ к таким вещам, как ввод/вывод, работа с файловой системой, запуск процессов и
другое. Все необходимые функции окружения были сгруппированны в классов-наследников стандартной монады так, как представлено выше (на данной диаграмме
отображены _не все_ классы, определённые в нашем приложении, а только самые важные):

* *MonadError* — монада для вызова и перехвата исключений в программе, оперирует стандартным (в рамках нашего приложения) типом ошибки `Data.Error`
* *MonadIO* — монада для ввода и вывода
* *MonadFS* — монада для поиска файлов в файловой системе компьютера
* *MonadPM* — монада для параллельного запуска и остановки процессов, оперирет типами `Stream` и `Process`, определяемыми типами-экземплярами
* *MonadVarReader* — монада для чтения значений переменных среды (локальных)
* *MonadVarWriter* — монада для записи значений переменных среды

### Главный цикл

![](./images/main_loop.svg)

Программа представляет собой цикл из 6 этапов:
1. *Reader* — получение строки-запроса от пользователя;
2. *Substitutor* — подстановка в запрос значений переменных среды, анализ синтаксических ошибок;
3. *Parser* — синтаксическое преобразование запроса, анализ синтаксических ошибок;
4. *Analyzer* — семантический анализ запроса, анализ логических ошибок (для внутренних команд);
5. *Linker* — связывание команд с логическими потоками ввода/вывода, оптимизация плана выполнения;
6. *Executor* — исполнение запроса (по возможности параллельно) по полученному плану.

Более подробно о каждом из этапов см. ниже.

### Ввод строки (Reader)

Состоит из 2 шагов:
1. *Вывод приветствия* (в нашем случае задаётся переменной `PS1`)
2. *Чтение пользовательской программы*, оканчивающейся знаком перевода строки

Переменная `PS1` имеет нестандартные специальные обозначения:

| Символ | Значение |
| ------ | -------- |
| `\[`   | Начало непечатаеммых символов (цвет, жирность и прочее) |
| `\]`   | Конец непечатаеммых символов |
| `\u`   | Имя текущего пользователя |
| `\w`   | Абсолютный путь до текущеи директории |
| `\h`   | Имя машины |
| `\d`   | Текущая дата |
| `\t`   | Текущее время |
| `\\`   | Символ обратной косой черты |

### Подстановка значений переменных (Substitutor)

![](./images/variable_substitutor.svg)

Здесь представлен фрагмент конечного автомата.
* Есть буффер `N` для записи имени переменной (при входе `N` пуст).
* Все переходы не пишут ничего на выход, запись происходит только в конце (стрелки никуда), причём записывается строка, "лежащая" в переменной с именем из `N`.
* Оранжевая стрелка ничего не делает (дополнительного), зелёная — запись символа в `N`, красная — "откат" чтения символа (мы как бы "подглядываем" следующий символ без его реального чтения).

![](./images/common_substitutor.svg)

Обработка строки, полученной на предыдущем этапе, выполняется с помощью конечного автомата, при этом записываем все прочитанные символы на выход (правда есть блок "разбор переменных", нарушающий данную семантику).

Нотация следующая:
* ЛСИП — латинский символ или подчёркивание;
* Стрелка без подписи означает переход по любому символу.

### Парсинг строки (Parser)

![](./images/primitive.svg)

![](./images/parser.svg)

Давайте сразу создадим словарь символов, на который будем в дальнейшем опираться:
- Элиминирующие символы: двойчные (`"`) и одинарные кавычки (`'`);
- Символ присваивания: `=`;
- Символ разбиения команд: `|`;
- Символ, разбивающий слова: пробел (` `).

Наш парсинг разделён на три иерархически связных блока:
* **Ввод первого слова** — тут мы обрабатываем первое слово для того, чтобы понять какому блоку отдать управление в дальнейшем.
  - **Условия ошибок**:
    1. Находясь в состоянии обработки элиминирующих символов мы можем встретить конец строки, который приведёт к незавершённости элиминирующей строки, тем самым это будет синтаксической ошибкой.
* **Ввод присваивания** — тут будет происходить присваивание переменной, где всё, что справа от символа присваивания будет являться значением, которое по нашей семантике мы будем сохранять по имени находящимся слева от знака символа присваивания.
  - **Условия ошибок**:
    1. Такая же обработка ошибок связанная с элиминирующими символами, как и в блоке ввода первого слова;
    2. Если мы встретим символ разделяющий на слова вне любых элиминирующих символов, то мы должны будем выдать ошибку, ведь мы предполагали, что всё, что правее символа присваивания должно быть единым словом, чтобы его можно было правильно интепретировать как значение. Ведь иначе нам будет не понятно, что имел ввиду пользователь.
* **Ввод команды** — если же мы не встретили знак присваивания или встретили конец строки или встретили любой символ, который не входит в слово (символ пробела) из состояния обработки обычных символов в вводе первого слова, то мы можем попытаться нашу общую строчку разбить на слова с помощью соотвествующего символа или на команды через символ разбиения на команды.
  - **Свойства:**
    - Состояние разбиения слов лишь ставит флаг о том, что если мы встретим символ входяший в новое слово, то мы начнём новое слово, а иначе разделяющий символ для слов, который идёт несколько раз подряд или который стоял перед символом, который не входит в новое слово -- просто проигнорируется (например если пробелы будут стоять перед символами разбиения на команды, то мы не будем начинать новое слово уже в предыдущей команде);
    - Кавычки мы обрабатываем аналогичным способом, как и в блоках выше;
    - Состояние разбиения команд будет ожидать символ входящий в новое слово, чтобы вернуть управление уже состоянию ввода команды, где командой уже будет являться новая последовательность слов.
  - **Условия ошибок**:
    1. Такая же обработка ошибок связанная с элиминирующими символами, как и в блоке ввода первого слова;
    2. Если находясь в состоянии разбиения команд мы встретили ещё один символ разбиения команд, то у нас получается, что команда является пустой -- а это, в свою очередь, невалидная конструкция.

Во всех остальных случаях конец строки является валидным состоянием и мы отдаём распарсшенную строчку дальнейшим модулям.

Преобразованный пользовательский запрос на выходе представлен на диаграмме ниже:

![](./images/parsed_primitive.svg)

То есть пользовательский запрос после парсинга — это либо список команд с аргументами, либо операция присваивания.

### Анализ команд (Analyzer)

![](./images/analyzed_primitive.svg)

В случае, если примитив является присваиванием, то на этой стадии ничего особенного не происходит,
разве что проверка, что введённое имя является обычной переменной
(в коде она стабильная для простоты иерархии, к тому же имена специфических переменных отбросятся на этапе парсинга).

Иначе каждая команда в списке анализируется и отождествляется с одним из классов из диаграммы выше.

Специальная (Special) команда — это
* `exit` — команда завершения программы, принимает опциональным параметром код возврата (0 по умолчанию);
* `cd` — команда смены текущей директории.

Обычная (Common) команда — это команда, имеющая потоки ввода и вывода, и, следовательно, такие команды можно собирать в цепочки через pipeы.

Внутренняя команда — это
* `cat` — команда печати содержимого файла, путь к которому передаётся в качестве единственного и обязательного параметра;
* `echo` — команда печати всех своих аргументов через пробел;
* `wc` — команда печати статистики содержимого файла (количество строк, количество слов, количество байт), путь к которому
передаётся в качестве единственного и обязательного параметра;
* `pwd` — команда печати абсолютного пути до текущей директории, параметров не принимает;
* `grep` — команда фильтрации ввода по регулярному выражению.

Внешняя команда — это путь до исполняемого файла вместе с аргументами.

Также отдельно выделяется пустая команда по историческим причинам.

Также на этом этапе:
* Для специальных и внутренних команд проверяется количество аргументов и их корректность (например, что аргумент команды `cat` является путём до существующего
  файла с разрешением на чтение);
* Для внешних команд ищется конкретный путь до неё через `PATH` и проверяется наличие разрешения на вызов;
* Для множества команд, написанных через pipe, проверяется отсутствие среди них специальной команды.

### Линковка команд (Linker)

![](./images/linked_primitive.svg)

После анализа программ запускается процесс связывания команд. Под связыванием здесь понимается определение для каждой команды её логических потоков ввода и вывода
(именно логических, так как физические определяются уже самим окружением, реализующим различные абстракции, в частности запуск процессов с
перенаправленными потоками).

Попутно на этом этапе происходит разбиение внутренних команд на чистые (Pure) и грязные (Impure). Гарантируется, что чистые работают только
с текстом из логического ввода (и со своими аргументами) и по каким-то правилам получают результат, который пишется в логический вывод.
Грязные же дополнительно используют информацию от системы, но _никак не модифицируют_ её.
Также на этом этапе происходит различного рода оптимизация, связанная с внутренними командами.

### Выполнение команд (Executor)

Выполнение *примитива* происходит следующим образом:
* при присваивании обновляем хранилище переменных
* при списке команд выполняем их с учётом плана запроса (то есть с логичекими потоками ввода и вывода)

Выполнение *команды* происходит следующим образом:
* специальная команда влияет на работу оболочки (в частности `exit` завершает работу)
* внутренняя сразу исполняется самой оболочкой (в частности `pwd` пишет в вывод свои аргументы)
* внешняя запускается по пути с соответствующими аргументами (но результат её работы не ожидается, а идёт исполнение следующей команды)

При возникновении ошибки (ненулевого кода возврата) одной из команд выполняется остановка уже работающих процессов, запуск новых процессов не производится,
после чего в переменную `?` происходит запись этого кода возврата. При нормальном завершении всех команд значение переменной `?` будет равно `0`.

## Используемые библиотеки
Для разбора аргументов `grep` используется библиотека `optparse-applicative`.
Выбор был из [списка на Haskell Wiki](https://wiki.haskell.org/Command_line_option_parsers).
В рассмотрение брались только библиотеки, доступные для GHC 9.2.5 (используемая в проекте версия),
из них `optparse-applicative` — самая популярная, её легко было внедрить в существующий код,
её просто использовать и у неё понятная документация.

Для полного сравнения имело бы смысл реализовать парсер на нескольких библиотеках,
и затем сравнить в первую очередь простоту использования,
но время на принятие решения было ограничено, и выбор был сделан частично наугад
— по тому, какая библиотека оказалась выше в поисковой выдаче,
после этого только подтверждён достаточным качеством найденной библиотеки.
