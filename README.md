# Архитектура CLI

Команда:
* Кузиванов Сергей
* Самсонов Павел
* Суркис Антон

Фазы:
* _белые компоненты_ будут реализованы на 1 фазе
* _фиолетовые_ — на 2 фазе
* _зелёные_ — на 1 фазе, но во 2 фазе будут удалены

[Ссылка](https://drive.google.com/file/d/1Nv47i6H_2Y60PWEcxgYel1UN4rp1yos5/view?usp=sharing) на диаграммы.

## Главный цикл

![](./images/main_loop.svg)

Программа представляет собой цикл из 4 этапов:
1. *Ввод строки* — получение строки от пользователя;
2. *Подстановка значений переменных* — преобразование строки;
3. *Парсинг строки* — получение примитива или синтаксической ошибки;
4. *Диспетчеризация команд* — получение примитива с дополнительной информацией или ошибки;
5. *Выполнение команд* — получение флага, нужно ли завершить работу оболочки или нет.

Более подробно о каждом из этапов см. ниже.

Также существует отдельный "модуль" для хранения значений переменных окружения, к которому этап *Подстановка значений переменных*
имеет доступ на чтение, а этап *Выполнение команд* — на чтение и запись.

## Ввод строки

Состоит из 2 шагов:
1. *Вывод приветствия* (в нашем случае строки "$ ")
2. *Чтение пользовательской программы*, оканчивающейся знаком перевода строки

## Подстановка значений переменных

![](./images/variable_substitutor.svg)

Здесь представлен фрагмент конечного автомата.
* Есть буффер `N` для записи имени переменной (при входе `N` пуст).
* Все переходы не пишут ничего на выход, запись происходит только в конце (стрелки никуда), причём записывается строка, "лежащая" в переменной с именем из `N`.
* Оранжевая стрелка ничего не делает (дополнительного), зелёная — запись символа в `N`, красная — "откат" чтения символа (мы как бы "подглядываем" следующий символ без его реального чтения).

![](./images/common_substitutor.svg)

Обработка строки, полученной на предыдущем этапе, выполняется с помощью конечного автомата, при этом записываем все прочитанные символы на выход (правда есть блок "разбор переменных", нарушающий данную семантику).

Нотация следующая:
* ЛСИП — латинский символ или подчёркивание;
* Стрелка без подписи означает переход по любому символу.

## Парсинг строки

![](./images/primitive.svg)

![](./images/parser.svg)

Давайте сразу создадим словарь символов на который будем в дальнейшем опираться:
- Элиминирующие символы: двойчные (`"`) и одинарные кавычки (`'`);
- Символ присваивания: `=`;
- Символ разбиения команд: `|`;
- Символ разбивающий слова: пробел (` `).

Наш парсинг разделён на три иерархически связных блока:
* **Ввод первого слова** — тут мы обрабатываем первое слово для того, чтобы понять какому блоку отдать управление в дальнейшем.
  - **Условия ошибок**:
    1. Находясь в состоянии обработки элиминирующих символов мы можем встретить конец строки, который приведёт к незавершённости элиминирующей строки, тем самым это будет синтаксической ошибкой.
* **Ввод присваивания** — тут будет происходить присваивание переменной, где всё, что справа от символа присваивания будет являться значением, которое по нашей семантике мы будем сохранять по имени находящимся слева от знака символа присваивания.
  - **Условия ошибок**:
    1. Такая же обработка ошибок связанная с элиминирующими символами, как и в блоке ввода первого слова;
    2. Если мы встретим символ разделяющий на слова вне любых элиминирующих символов, то мы должны будем выдать ошибку, ведь мы предполагали, что всё, что правее символа присваивания должно быть единым словом, чтобы его можно было правильно интепретировать как значение. Ведь иначе нам будет не понятно, что имел ввиду пользователь.
* **Ввод команды** — если же мы не встретили знак присваивания или встретили конец строки или встретили любой символ, который не входит в слово (символ пробела) из состояния обработки обычных символов в вводе первого слова, то мы можем попытаться нашу общую строчку разбить на слова с помощью соотвествующего символа или на команды через символ разбиения на команды.
  - **Свойства:**
    - Состояние разбиения слов лишь ставит флаг о том, что если мы встретим символ входяший в новое слово, то мы начнём новое слово, а иначе разделяющий символ для слов, который идёт несколько раз подряд или который стоял перед символом, который не входит в новое слово -- просто проигнорируется (например если пробелы будут стоять перед символами разбиения на команды, то мы не будем начинать новое слово уже в предыдущей команде);
    - Кавычки мы обрабатываем аналогичным способом, как и в блоках выше;
    - Состояние разбиения команд будет ожидать символ входящий в новое слово, чтобы вернуть управление уже состоянию ввода команды, где командой уже будет являться новая последовательность слов.
  - **Условия ошибок**:
    1. Такая же обработка ошибок связанная с элиминирующими символами, как и в блоке ввода первого слова;
    2. Если находясь в состоянии разбиения команд мы встретили ещё один символ разбиения команд, то у нас получается, что команда является пустой -- а это, в свою очередь, невалидная конструкция.

Во всех остальных случаях конец строки является валидным состоянием и мы отдаём распарсшенную строчку дальнейшим модулям.

## Диспетчеризация команд

![](/images/primitive++.svg)

В случае, если примитив является присваиванием, то на этой стадии ничего не происходит. Иначе каждая команда в списке
анализируется и отождествляется с одним из 3 листовых классов из диаграммы выше (специальная, внутренняя или внешняя).

Специальная команда — это
* `exit` — команда завершения программы, принимает опциональным параметром код возврата (0 по умолчанию).

Внутренняя команда — это
* `cat` — команда печати содержимого файла, путь к которому передаётся в качестве единственного и обязательного параметра;
* `echo` — команда печати всех своих аргументов через пробел;
* `wc` — команда печати статистики содержимого файла (количество строк, количество слов, количество байт), путь к которому
передаётся в качестве единственного и обязательного параметра;
* `pwd` — команда печати абсолютного пути до текущей директории, параметров не принимает.

Внешняя команда — это не специальная и не внутренняя команда.

Также на этом этапе:
* Для специальных и внутренних команд проверяется правильность количества аргументов (а также их корректность, например, что указанный аргумент
команды `cat` является путём до существующего файла, причём также проверяется, что этот файл имеет доступ на чтение) и находится внутренний обработчик
(объект, который будет запущен на следующем этапе при запуске команды);
* Для внешних команд ищется конкретный путь до неё через `PATH` и проверяется наличие разрешения на вызов;
* Для множества команд, написанных через pipe, проверяется отсутствие среди них специальной команды.

При проблемах (неверное количество аргументов внутренней команды или отсутствие разрешения на вызов у исполняемого файла) на этом этапе выбрасывается
ошибка, после чего следующий этап не запускается (если говорить про реализацию, то для этого используется класс `MonadError`).

Замечание: в последних версиях был добавлен отдельный этап обработки пользовательского запроса (Linker), идущий сразу после этого, на котором происходит
приписывание каждой команде потоков ввода и вывода, поток ошибок используется стандартный для всех команд.

## Выполнение команд

Выполнение *примитива* происходит следующим образом:
* при присваивании обновляем хранилище переменных
* при списке команд выполняем их с перенаправлением ввода/вывода

Выполнение *команды* происходит следующим образом:
* специальная команда влияет на работу оболочки (в частности `exit` завершает работу)
* внутренняя исполняется самой оболочкой (в частности `echo` пишет в вывод свои аргументы)
* внешняя запускается по пути с соответствующими аргументами

Код возврата команды игнорируется (его, конечно, можно записывать в переменную с именем `?`, но пока в задаче этого не требуется).

## Описание команд

* `echo [TEXT]`: команда выводит TEXT в свой stdout и переводит строку.
  Если передано несколько аргументов, они выводятся через пробел.
  Если не передано ни одного, выводится пустая строка.
* `cat <FILE>`: FILE — обязательный аргумент, путь к файлу.
  Команда выводит содержимое файла в свой stdout.
* `wc [FILE]`: FILE — необязательный аргумент, путь к файлу.
  Команда считает текст из входного файла (если он не предоставлен — из stdin)
  и выводит через символ табуляции количество строк, слов и символов в прочитанном тексте.
* `pwd`: команда выводит текущую директорию.
* `exit`: команда завершает выполнение.

Если одной из этих команд переданы некорректные аргументы
(например, их слишком много, или не найден файл),
то будет выведена ошибка и выполнения команд не произойдёт.

Для команды `exit` ошибкой также является включение её в пайп,
остальные команды не различают пайп и "честный" ввод-вывод.
