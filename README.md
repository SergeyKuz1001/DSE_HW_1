# Реализация CLI, часть 2

Команда:
* Кузиванов Сергей
* Самсонов Павел
* Суркис Антон

## Куда смотреть?

* `app/*` — папка с реальной программой (точка входа + окружение, в котором всё работает)
* `src/*` — папка с абстрактной программой, то есть все действия происходят в пока неизвестном окружении (сделано для упрощения тестирования)
  * `src/Phases/*` — модули с фазами (этапами) обработки пользовательского запроса
  * `src/Data/*` — модули с типами данных, используемых в программе
  * `src/Monads/*` — модули с классами типов, расширяющих класс `Monad` путём добавления новых полезных функций (все функции вместе создают необходимый в работе программы интерфейс `IO`-like монады)
* `test/*` — папка с unit-тестами на фазы (на все кроме первой)

## Как протестировать?

Добавилась новая полезная функция, позволяющая во время работы программы получать промежуточные представления пользовательского запроса.

Для вывода промежуточного представления запроса после этапа `X` нужно добавить в переменную `DEBUG_OPTIONS` символ `Y`. Список вида `Y — X`:

* `r` — `reader` (считывает пользовательский ввод)
* `s` — `substitutor` (подставляет значения переменных в пользовательский запрос)
* `p` — `parser` (разбирает запрос и проводит первичный анализ)
* `a` — `analyzer` (анализ запроса, проверка правильности аргументов и т. д.)
* `l` — `linker` (построение плана выполнения запроса и его оптимизация)

Таким образом, чтобы получать полную информацию по каждому из запросов, достаточно набрать в программе

```sh
DEBUG_OPTIONS=rspal
```

# Реализация CLI, часть 1

Команда:
* Кузиванов Сергей
* Самсонов Павел
* Суркис Антон

## Куда смотреть?

* `app/Main.hs` — модуль с точкой входа в программу, главный цикл программы
* `src/*` — библиотека, основные модули программы; для этой папки существует документация, доступная по этой [ссылке](https://sergeykuz1001.github.io/SD_HW_1/)
  * `src/Phases/*` — модули с фазами (этапами) программы
  * `src/Phases.hs` — собирательный модуль
  * `src/Data/*` — модули с типами, с помощью которых происходит взаимодействие между фазами
  * `src/Environment/*` — модули с классами, предоставляющими различные функции для работы с абстрактной `IO`-like монадой
  * `src/Environment` — модуль с монадой, внутри которой работает данное приложение
* `test/*` — модули с unit-тестами

## Как собрать?

Нужна система сборки `stack` для Haskell. Рекомендуемый способ установки — через [GHCup](https://www.haskell.org/ghcup/).
Это же требование распространяется и на тестирование и запуск из рабочего окружения.

Для сборки из корневой директории проекта ввести:
```sh
stack build
```

## Как протестировать?

```sh
stack test
```

(запускаются только unit-тесты)

## Как запустить?

```sh
stack run
```

Перед запуском произойдёт сборка (если необходимо) + могут быть записаны различные предупреждения, касающиеся `stack`а.
Для простого запуска собранного приложения под Linux можно написать

```sh
`stack path --local-install-root 2> /dev/null`/bin/cli-exe
```

# Архитектура CLI

Команда:
* Кузиванов Сергей
* Самсонов Павел
* Суркис Антон

Фазы:
* _белые компоненты_ будут реализованы на 1 фазе
* _фиолетовые_ — на 2 фазе
* _зелёные_ — на 1 фазе, но во 2 фазе будут удалены

[Ссылка](https://drive.google.com/file/d/1Nv47i6H_2Y60PWEcxgYel1UN4rp1yos5/view?usp=sharing) на диаграммы.

## Главный цикл

![](./images/main_loop.svg)

Программа представляет собой цикл из 4 этапов:
1. *Ввод строки* — получение строки от пользователя;
2. *Подстановка значений переменных* — преобразование строки;
3. *Парсинг строки* — получение примитива или синтаксической ошибки;
4. *Диспетчеризация команд* — получение примитива с дополнительной информацией или ошибки;
5. *Выполнение команд* — получение флага, нужно ли завершить работу оболочки или нет.

Более подробно о каждом из этапов см. ниже.

Также существует отдельный "модуль" для хранения значений переменных окружения, к которому этап *Подстановка значений переменных*
имеет доступ на чтение, а этап *Выполнение команд* — на чтение и запись.

## Ввод строки

Состоит из 2 шагов:
1. *Вывод приветствия* (в нашем случае строки "$ ")
2. *Чтение пользовательской программы*, оканчивающейся знаком перевода строки

## Подстановка значений переменных

![](./images/variable_substitutor.svg)

Здесь представлен фрагмент конечного автомата.
* Есть буффер `N` для записи имени переменной (при входе `N` пуст).
* Все переходы не пишут ничего на выход, запись происходит только в конце (стрелки никуда), причём записывается строка, "лежащая" в переменной с именем из `N`.
* Оранжевая стрелка ничего не делает (дополнительного), зелёная — запись символа в `N`, красная — "откат" чтения символа (мы как бы "подглядываем" следующий символ без его реального чтения).

![](./images/common_substitutor.svg)

Обработка строки, полученной на предыдущем этапе, выполняется с помощью конечного автомата, при этом записываем все прочитанные символы на выход (правда есть блок "разбор переменных", нарушающий данную семантику).

Нотация следующая:
* ЛСИП — латинский символ или подчёркивание;
* Стрелка без подписи означает переход по любому символу.

## Парсинг строки

![](./images/primitive.svg)

![](./images/parser.svg)

Давайте сразу создадим словарь символов на который будем в дальнейшем опираться:
- Элиминирующие символы: двойчные (`"`) и одинарные кавычки (`'`);
- Символ присваивания: `=`;
- Символ разбиения команд: `|`;
- Символ разбивающий слова: пробел (` `).

Наш парсинг разделён на три иерархически связных блока:
* **Ввод первого слова** — тут мы обрабатываем первое слово для того, чтобы понять какому блоку отдать управление в дальнейшем.
  - **Условия ошибок**:
    1. Находясь в состоянии обработки элиминирующих символов мы можем встретить конец строки, который приведёт к незавершённости элиминирующей строки, тем самым это будет синтаксической ошибкой.
* **Ввод присваивания** — тут будет происходить присваивание переменной, где всё, что справа от символа присваивания будет являться значением, которое по нашей семантике мы будем сохранять по имени находящимся слева от знака символа присваивания.
  - **Условия ошибок**:
    1. Такая же обработка ошибок связанная с элиминирующими символами, как и в блоке ввода первого слова;
    2. Если мы встретим символ разделяющий на слова вне любых элиминирующих символов, то мы должны будем выдать ошибку, ведь мы предполагали, что всё, что правее символа присваивания должно быть единым словом, чтобы его можно было правильно интепретировать как значение. Ведь иначе нам будет не понятно, что имел ввиду пользователь.
* **Ввод команды** — если же мы не встретили знак присваивания или встретили конец строки или встретили любой символ, который не входит в слово (символ пробела) из состояния обработки обычных символов в вводе первого слова, то мы можем попытаться нашу общую строчку разбить на слова с помощью соотвествующего символа или на команды через символ разбиения на команды.
  - **Свойства:**
    - Состояние разбиения слов лишь ставит флаг о том, что если мы встретим символ входяший в новое слово, то мы начнём новое слово, а иначе разделяющий символ для слов, который идёт несколько раз подряд или который стоял перед символом, который не входит в новое слово -- просто проигнорируется (например если пробелы будут стоять перед символами разбиения на команды, то мы не будем начинать новое слово уже в предыдущей команде);
    - Кавычки мы обрабатываем аналогичным способом, как и в блоках выше;
    - Состояние разбиения команд будет ожидать символ входящий в новое слово, чтобы вернуть управление уже состоянию ввода команды, где командой уже будет являться новая последовательность слов.
  - **Условия ошибок**:
    1. Такая же обработка ошибок связанная с элиминирующими символами, как и в блоке ввода первого слова;
    2. Если находясь в состоянии разбиения команд мы встретили ещё один символ разбиения команд, то у нас получается, что команда является пустой -- а это, в свою очередь, невалидная конструкция.

Во всех остальных случаях конец строки является валидным состоянием и мы отдаём распарсшенную строчку дальнейшим модулям.

## Диспетчеризация команд

![](/images/primitive++.svg)

В случае, если примитив является присваиванием, то на этой стадии ничего не происходит. Иначе каждая команда в списке
анализируется и отождествляется с одним из 3 листовых классов из диаграммы выше (специальная, внутренняя или внешняя).

Специальная команда — это
* `exit` — команда завершения программы, принимает опциональным параметром код возврата (0 по умолчанию).

Внутренняя команда — это
* `cat` — команда печати содержимого файла, путь к которому передаётся в качестве единственного и обязательного параметра;
* `echo` — команда печати всех своих аргументов через пробел;
* `wc` — команда печати статистики содержимого файла (количество строк, количество слов, количество байт), путь к которому
передаётся в качестве единственного и обязательного параметра;
* `pwd` — команда печати абсолютного пути до текущей директории, параметров не принимает.

Внешняя команда — это не специальная и не внутренняя команда.

Также на этом этапе:
* Для специальных и внутренних команд проверяется правильность количества аргументов и находится внутренний обработчик
(объект, который будет запущен на следующем этапе при запуске команды);
* Для внешних команд ищется конкретный путь до неё через `PATH` и проверяется наличие разрешения на вызов;
* Для множества команд, написанных через pipe, проверяется отсутствие среди них специальной команды.

## Выполнение команд

Выполнение *примитива* происходит следующим образом:
* при присваивании обновляем хранилище переменных
* при списке команд выполняем их с перенаправлением ввода/вывода

Выполнение *команды* происходит следующим образом:
* специальная команда влияет на работу оболочки (в частности `exit` завершает работу)
* внутренняя исполняется самой оболочкой (в частности `echo` пишет в вывод свои аргументы)
* внешняя запускается по пути с соответствующими аргументами

Код возврата команды игнорируется (его, конечно, можно записывать в переменную с именем `?`, но пока в задаче этого не требуется).
